/ *
Given an array A[] consisting of 0’s and 1’s. A flip operation is one in which you turn 1 into 0 and a 0 into 1. You have to do at most one “Flip” operation of any subarray. Formally, select a range (l, r) in the array A[], such that (0 ≤ l ≤ r < n) holds and flip the elements in this range to get the maximum ones in the final array. You can possibly make zero operations to get the answer. You are asked to return the maximum number of 1 you can get in the array after doing flip operation.

input:
N = 5
A[] = {1, 0, 0, 1, 0} 
Output:
4
Explanation:
We can perform a flip operation in the range [1,2]
After flip operation array is : [ 1 1 1 1 0 ]
Count of one after fliping is : 4
[Note: the subarray marked in bold is the flipped subarray]

Input:
N = 7
A[] = {1, 0, 0, 1, 0, 0, 1}
Output:
6
Explanation:
We can perform a flip operation in the range [1,5]
After flip operation array is : [ 1 1 1 0 1 1 1]
Count of one after fliping is : 6
[Note: the subarray marked in bold is the flipped subarray]

*/ 


class Solution {

    public static int maxOnes(int arr[], int n) {
        // Your code goes here
        int count=0;
        
        for(int i=0; i<n; i++){
            if(arr[i] == 0){
                arr[i] = 1;
            }else{
                arr[i] = -1;
                count++;
            }
        }
        
        int csum = 0;
        int osum = 0;
        
        for(int i=0; i<n; i++){
            if(csum >= 0 ){
                csum += arr[i];
            }else{
                csum = arr[i];
            }
            
            osum = Math.max(osum, csum);
        }
        
        if(osum >0){
            return osum +count;
        }else{
            return count;
        }
    }
}
